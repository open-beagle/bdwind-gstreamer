<!DOCTYPE html>
<html>

<head>
  <title>WebRTC Desktop Capture Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      color: #333;
      margin-bottom: 10px;
    }

    .header p {
      color: #666;
    }

    video {
      width: 100%;
      max-width: 800px;
      height: auto;
      border: 2px solid #333;
      background: #000;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .video-container {
      text-align: center;
      margin-bottom: 20px;
    }

    .controls {
      text-align: center;
      margin: 20px 0;
    }

    button {
      margin: 5px;
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .btn-primary {
      background: #007bff;
      color: white;
    }

    .btn-primary:hover {
      background: #0056b3;
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-secondary:hover {
      background: #545b62;
    }

    .btn-danger {
      background: #dc3545;
      color: white;
    }

    .btn-danger:hover {
      background: #c82333;
    }

    .status {
      margin: 20px 0;
      padding: 15px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      text-align: center;
    }

    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-ready {
      background: #28a745;
    }

    .status-connecting {
      background: #ffc107;
    }

    .status-connected {
      background: #007bff;
    }

    .status-error {
      background: #dc3545;
    }

    .logs {
      height: 400px;
      overflow-y: scroll;
      border: 1px solid #ddd;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }

    .stat-card {
      background: #fff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      text-align: center;
    }

    .stat-title {
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
    }

    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #333;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>WebRTC Desktop Capture Test</h1>
      <p>æµ‹è¯•æ¡Œé¢æ•è·å’Œ WebRTC æµåª’ä½“åŠŸèƒ½ï¼ˆä½¿ç”¨ webrtc.js + signaling.jsï¼‰</p>
    </div>

    <div class="video-container">
      <video id="remoteVideo" autoplay playsinline muted></video>
    </div>

    <div class="controls">
      <button class="btn-primary" onclick="app.start()">å¼€å§‹æ¡Œé¢æ•è·</button>
      <button class="btn-danger" onclick="app.stop()">åœæ­¢æ•è·</button>
      <button class="btn-secondary" onclick="app.clearLogs()">æ¸…é™¤æ—¥å¿—</button>
      <button class="btn-secondary" onclick="app.toggleStats()">æ˜¾ç¤º/éšè—ç»Ÿè®¡</button>
      <button class="btn-secondary" onclick="app.toggleICEConfig()">ICE é…ç½®</button>
    </div>

    <!-- ICE é…ç½®é¢æ¿ -->
    <div id="iceConfigPanel" style="display: none; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin: 20px 0;">
      <h3 style="margin-top: 0;">ICE å€™é€‰ç­›é€‰é…ç½®</h3>
      
      <div style="margin-bottom: 15px;">
        <label style="display: block; margin-bottom: 5px; font-weight: bold;">è¿æ¥ç­–ç•¥:</label>
        <select id="iceStrategy" onchange="app.applyICEStrategy()" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
          <option value="prefer-srflx" selected>ä¼˜å…ˆ SRFLXï¼ˆæ¨èç”¨äºNATç©¿é€ï¼‰</option>
          <option value="only-srflx">ä»… SRFLXï¼ˆä¸¥æ ¼æ¨¡å¼ï¼‰- æµ‹è¯• SRFLX è¿æ¥</option>
          <option value="prefer-relay">ä¼˜å…ˆ RELAYï¼ˆTURNæœåŠ¡å™¨ï¼‰</option>
          <option value="only-relay">ä»… RELAYï¼ˆå¼ºåˆ¶TURNï¼‰</option>
          <option value="all">å…¨éƒ¨ç±»å‹ï¼ˆé»˜è®¤ï¼‰</option>
        </select>
      </div>

      <div style="margin-bottom: 15px;">
        <label style="display: flex; align-items: center;">
          <input type="checkbox" id="blockIPv6LinkLocal" checked onchange="app.applyICEStrategy()" style="margin-right: 8px;">
          <span>é˜»æ­¢ IPv6 Link-Local åœ°å€</span>
        </label>
      </div>

      <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 13px;">
        <strong>å½“å‰é…ç½®:</strong>
        <div id="currentICEConfig" style="margin-top: 5px; font-family: monospace;"></div>
      </div>

      <div style="margin-top: 15px; padding: 10px; background: #e7f3ff; border-left: 4px solid #007bff; border-radius: 4px; font-size: 13px;">
        <strong>ğŸ’¡ æç¤º:</strong>
        <ul style="margin: 5px 0; padding-left: 20px;">
          <li><strong>SRFLX</strong>: é€šè¿‡STUNæœåŠ¡å™¨è·å–çš„å…¬ç½‘åœ°å€ï¼Œé€‚åˆNATç©¿é€</li>
          <li><strong>RELAY</strong>: é€šè¿‡TURNæœåŠ¡å™¨ä¸­ç»§ï¼Œé€‚åˆä¸¥æ ¼é˜²ç«å¢™ç¯å¢ƒ</li>
          <li><strong>HOST</strong>: æœ¬åœ°ç½‘ç»œåœ°å€ï¼Œé€‚åˆå±€åŸŸç½‘è¿æ¥</li>
        </ul>
      </div>
    </div>

    <div class="status">
      <span class="status-indicator status-ready" id="statusIndicator"></span>
      <strong>çŠ¶æ€:</strong> <span id="status">å‡†å¤‡å°±ç»ª</span>
    </div>

    <div class="stats-grid" id="statsGrid" style="display: none;">
      <div class="stat-card">
        <div class="stat-title">è¿æ¥çŠ¶æ€</div>
        <div class="stat-value" id="connectionState">æœªè¿æ¥</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">ICE çŠ¶æ€</div>
        <div class="stat-value" id="iceState">æ–°å»º</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">è§†é¢‘è½¨é“</div>
        <div class="stat-value" id="videoTracks">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">éŸ³é¢‘è½¨é“</div>
        <div class="stat-value" id="audioTracks">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">æ¥æ”¶å­—èŠ‚æ•°</div>
        <div class="stat-value" id="bytesReceived">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">å·²è§£ç å¸§æ•°</div>
        <div class="stat-value" id="framesDecoded">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">å…³é”®å¸§æ•°</div>
        <div class="stat-value" id="keyFramesDecoded">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">è§£ç å™¨</div>
        <div class="stat-value" id="decoderImplementation">-</div>
      </div>
    </div>

    <div class="logs" id="logs"></div>
  </div>

  <!-- å¼•å…¥å¤–éƒ¨JSæ–‡ä»¶ -->
  <script src="signaling.js?v=8"></script>
  <script src="webrtc.js?v=8"></script>
  
  <!-- åº”ç”¨é€»è¾‘ -->
  <script>
    // æ£€æŸ¥ä¾èµ–æ˜¯å¦åŠ è½½
    if (typeof SignalingClient === 'undefined') {
      console.error('âŒ SignalingClient æœªåŠ è½½ï¼è¯·æ£€æŸ¥ signaling.js æ–‡ä»¶');
      alert('é”™è¯¯ï¼šSignalingClient æœªåŠ è½½ã€‚è¯·åˆ·æ–°é¡µé¢æˆ–æ£€æŸ¥æ§åˆ¶å°ã€‚');
    }
    if (typeof WebRTCManager === 'undefined') {
      console.error('âŒ WebRTCManager æœªåŠ è½½ï¼è¯·æ£€æŸ¥ webrtc.js æ–‡ä»¶');
      alert('é”™è¯¯ï¼šWebRTCManager æœªåŠ è½½ã€‚è¯·åˆ·æ–°é¡µé¢æˆ–æ£€æŸ¥æ§åˆ¶å°ã€‚');
    }
    
    // åº”ç”¨çŠ¶æ€
    const app = {
      signaling: null,
      webrtc: null,
      statsVisible: false,
      statsInterval: null,
      iceConfigVisible: false,

      // åˆå§‹åŒ–
      init() {
        this.log('é¡µé¢åŠ è½½å®Œæˆï¼Œå‡†å¤‡å¼€å§‹æ¡Œé¢æ•è·æµ‹è¯•', 'success');
        this.log('ç‚¹å‡» "å¼€å§‹æ¡Œé¢æ•è·" æŒ‰é’®å¼€å§‹æµ‹è¯•', 'info');
        this.log('ğŸ”§ ä½¿ç”¨ webrtc.js + signaling.js æ¶æ„', 'info');
        this.log('ğŸ”§ é»˜è®¤ä½¿ç”¨ SRFLX ä¼˜å…ˆç­–ç•¥ï¼ˆé€‚åˆNATç©¿é€ï¼‰', 'info');
        this.updateICEConfigDisplay();
      },

      // åˆ‡æ¢ ICE é…ç½®é¢æ¿
      toggleICEConfig() {
        this.iceConfigVisible = !this.iceConfigVisible;
        document.getElementById('iceConfigPanel').style.display = 
          this.iceConfigVisible ? 'block' : 'none';
      },

      // åº”ç”¨ ICE ç­–ç•¥
      applyICEStrategy() {
        const strategy = document.getElementById('iceStrategy').value;
        const blockIPv6 = document.getElementById('blockIPv6LinkLocal').checked;

        let config = {
          blockIPv6LinkLocal: blockIPv6
        };

        switch (strategy) {
          case 'prefer-srflx':
            config.preferredTypes = ['srflx'];
            config.allowedTypes = ['srflx', 'relay', 'host'];
            config.strictMode = false;
            break;
          case 'only-srflx':
            config.preferredTypes = ['srflx'];
            config.allowedTypes = ['srflx'];
            config.strictMode = true;
            break;
          case 'prefer-relay':
            config.preferredTypes = ['relay'];
            config.allowedTypes = ['relay', 'srflx', 'host'];
            config.strictMode = false;
            break;
          case 'only-relay':
            config.preferredTypes = ['relay'];
            config.allowedTypes = ['relay'];
            config.strictMode = true;
            break;
          case 'all':
            config.preferredTypes = ['srflx', 'relay', 'host'];
            config.allowedTypes = ['srflx', 'relay', 'host'];
            config.strictMode = false;
            break;
        }

        if (this.webrtc) {
          this.webrtc.setICEFilterConfig(config);
          this.log(`ğŸ”§ ICEç­–ç•¥å·²æ›´æ–°: ${strategy}`, 'info');
        }

        this.updateICEConfigDisplay(config);
      },

      // æ›´æ–° ICE é…ç½®æ˜¾ç¤º
      updateICEConfigDisplay(config) {
        if (!config) {
          config = {
            preferredTypes: ['srflx'],
            allowedTypes: ['srflx', 'relay', 'host'],
            strictMode: false,
            blockIPv6LinkLocal: true
          };
        }

        const display = document.getElementById('currentICEConfig');
        if (display) {
          display.innerHTML = `
            ä¼˜å…ˆç±»å‹: ${config.preferredTypes.join(', ')}<br>
            å…è®¸ç±»å‹: ${config.allowedTypes.join(', ')}<br>
            ä¸¥æ ¼æ¨¡å¼: ${config.strictMode ? 'æ˜¯' : 'å¦'}<br>
            é˜»æ­¢IPv6 Link-Local: ${config.blockIPv6LinkLocal ? 'æ˜¯' : 'å¦'}
          `;
        }
      },

      // å¼€å§‹æ•è·
      async start() {
        try {
          this.log('å¼€å§‹æ¡Œé¢æ•è·æµ‹è¯•...', 'info');
          this.updateStatus('æ­£åœ¨è¿æ¥...', 'connecting');

          const video = document.getElementById('remoteVideo');

          // åˆ›å»ºä¿¡ä»¤å®¢æˆ·ç«¯
          this.signaling = new SignalingClient('/api/signaling', 1, {
            logger: console,
            maxRetries: 3,
            retryDelay: 3000
          });

          // è®¾ç½®ä¿¡ä»¤å›è°ƒ
          this.signaling.onstatus = (msg) => this.log(`ğŸ“¡ ä¿¡ä»¤: ${msg}`, 'info');
          this.signaling.onerror = (err) => this.log(`âŒ ä¿¡ä»¤é”™è¯¯: ${err.message}`, 'error');
          
          // åˆ›å»ºWebRTCç®¡ç†å™¨
          this.webrtc = new WebRTCManager(this.signaling, video, 1);

          // åº”ç”¨å½“å‰çš„ ICE ç­–ç•¥
          this.applyICEStrategy();

          // è®¾ç½®WebRTCå›è°ƒ
          this.webrtc.onstatus = (msg) => this.log(`ğŸ¥ WebRTC: ${msg}`, 'info');
          this.webrtc.ondebug = (msg) => this.log(`ğŸ› ${msg}`, 'info');
          this.webrtc.onerror = (msg) => this.log(`âŒ WebRTCé”™è¯¯: ${msg}`, 'error');
          
          this.webrtc.onconnectionstatechange = (state) => {
            this.log(`ğŸ”— è¿æ¥çŠ¶æ€: ${state}`, 'info');
            this.updateStatus(`è¿æ¥: ${state}`, state === 'connected' ? 'connected' : 'connecting');
            
            if (state === 'connected') {
              this.log('âœ… WebRTC è¿æ¥å»ºç«‹æˆåŠŸ!', 'success');
              this.updateStatus('æ¡Œé¢æ•è·å·²æ¿€æ´»', 'connected');
            } else if (state === 'failed') {
              this.log('âŒ WebRTC è¿æ¥å¤±è´¥', 'error');
              this.updateStatus('è¿æ¥å¤±è´¥', 'error');
            }
          };

          // è¿æ¥
          await this.webrtc.initialize();
          this.webrtc.connect();

          this.log('âœ… åˆå§‹åŒ–å®Œæˆ', 'success');

        } catch (error) {
          this.log(`âŒ å¯åŠ¨å¤±è´¥: ${error.message}`, 'error');
          this.updateStatus('å¯åŠ¨å¤±è´¥', 'error');
        }
      },

      // åœæ­¢æ•è·
      stop() {
        this.log('åœæ­¢æ¡Œé¢æ•è·...', 'info');

        if (this.webrtc) {
          this.webrtc.reset();
          this.webrtc = null;
        }

        if (this.signaling) {
          this.signaling.disconnect();
          this.signaling = null;
        }

        const video = document.getElementById('remoteVideo');
        video.srcObject = null;

        this.updateStatus('å·²åœæ­¢', 'ready');

        if (this.statsInterval) {
          clearInterval(this.statsInterval);
          this.statsInterval = null;
        }
      },

      // åˆ‡æ¢ç»Ÿè®¡æ˜¾ç¤º
      toggleStats() {
        this.statsVisible = !this.statsVisible;
        const statsGrid = document.getElementById('statsGrid');
        statsGrid.style.display = this.statsVisible ? 'grid' : 'none';

        if (this.statsVisible) {
          this.updateStats();
          if (!this.statsInterval) {
            this.statsInterval = setInterval(() => this.updateStats(), 1000);
          }
        } else {
          if (this.statsInterval) {
            clearInterval(this.statsInterval);
            this.statsInterval = null;
          }
        }
      },

      // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
      async updateStats() {
        if (!this.webrtc || !this.webrtc.peerConnection) return;

        const pc = this.webrtc.peerConnection;
        
        document.getElementById('connectionState').textContent = pc.connectionState;
        document.getElementById('iceState').textContent = pc.iceConnectionState;

        // ç»Ÿè®¡è½¨é“
        let videoTracks = 0;
        let audioTracks = 0;
        pc.getReceivers().forEach(receiver => {
          if (receiver.track) {
            if (receiver.track.kind === 'video') videoTracks++;
            if (receiver.track.kind === 'audio') audioTracks++;
          }
        });

        document.getElementById('videoTracks').textContent = videoTracks;
        document.getElementById('audioTracks').textContent = audioTracks;

        // è·å–è¯¦ç»†ç»Ÿè®¡
        try {
          const stats = await pc.getStats();
          let bytesReceived = 0;
          let framesDecoded = 0;
          let keyFramesDecoded = 0;
          let decoderImplementation = '-';

          stats.forEach(report => {
            if (report.type === 'inbound-rtp' && report.kind === 'video') {
              bytesReceived = report.bytesReceived || 0;
              framesDecoded = report.framesDecoded || 0;
              keyFramesDecoded = report.keyFramesDecoded || 0;
              decoderImplementation = report.decoderImplementation || '-';
            }
          });

          document.getElementById('bytesReceived').textContent = (bytesReceived / 1024).toFixed(1) + ' KB';
          document.getElementById('framesDecoded').textContent = framesDecoded;
          document.getElementById('keyFramesDecoded').textContent = keyFramesDecoded;
          document.getElementById('decoderImplementation').textContent = decoderImplementation;
        } catch (error) {
          console.error('è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥:', error);
        }
      },

      // æ¸…é™¤æ—¥å¿—
      clearLogs() {
        document.getElementById('logs').innerHTML = '';
      },

      // è®°å½•æ—¥å¿—
      log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const icon = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : type === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
        const logEntry = `[${timestamp}] ${icon} ${message}`;
        
        const logsDiv = document.getElementById('logs');
        logsDiv.innerHTML += logEntry + '<br>';
        logsDiv.scrollTop = logsDiv.scrollHeight;
        
        console.log(logEntry);
      },

      // æ›´æ–°çŠ¶æ€
      updateStatus(status, type = 'ready') {
        document.getElementById('status').textContent = status;
        document.getElementById('statusIndicator').className = `status-indicator status-${type}`;
      }
    };

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    window.addEventListener('DOMContentLoaded', () => app.init());
  </script>
</body>

</html>
