<!DOCTYPE html>
<html>

<head>
  <title>WebRTC Desktop Capture Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      color: #333;
      margin-bottom: 10px;
    }

    .header p {
      color: #666;
    }

    video {
      width: 100%;
      max-width: 800px;
      height: auto;
      border: 2px solid #333;
      background: #000;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .video-container {
      text-align: center;
      margin-bottom: 20px;
    }

    .controls {
      text-align: center;
      margin: 20px 0;
    }

    button {
      margin: 5px;
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .btn-primary {
      background: #007bff;
      color: white;
    }

    .btn-primary:hover {
      background: #0056b3;
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-secondary:hover {
      background: #545b62;
    }

    .btn-danger {
      background: #dc3545;
      color: white;
    }

    .btn-danger:hover {
      background: #c82333;
    }

    .status {
      margin: 20px 0;
      padding: 15px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      text-align: center;
    }

    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-ready {
      background: #28a745;
    }

    .status-connecting {
      background: #ffc107;
    }

    .status-connected {
      background: #007bff;
    }

    .status-error {
      background: #dc3545;
    }

    .logs {
      height: 400px;
      overflow-y: scroll;
      border: 1px solid #ddd;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }

    .stat-card {
      background: #fff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      text-align: center;
    }

    .stat-title {
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
    }

    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #333;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>WebRTC Desktop Capture Test</h1>
      <p>æµ‹è¯•æ¡Œé¢æ•è·å’Œ WebRTC æµåª’ä½“åŠŸèƒ½</p>
    </div>

    <div class="video-container">
      <video id="remoteVideo" autoplay playsinline muted></video>
    </div>

    <div class="controls">
      <button class="btn-primary" onclick="startCapture()">å¼€å§‹æ¡Œé¢æ•è·</button>
      <button class="btn-danger" onclick="stopCapture()">åœæ­¢æ•è·</button>
      <button class="btn-secondary" onclick="clearLogs()">æ¸…é™¤æ—¥å¿—</button>
      <button class="btn-secondary" onclick="toggleStats()">æ˜¾ç¤º/éšè—ç»Ÿè®¡</button>
    </div>

    <div class="status">
      <span class="status-indicator status-ready" id="statusIndicator"></span>
      <strong>çŠ¶æ€:</strong> <span id="status">å‡†å¤‡å°±ç»ª</span>
    </div>

    <div class="stats-grid" id="statsGrid" style="display: none;">
      <div class="stat-card">
        <div class="stat-title">è¿æ¥çŠ¶æ€</div>
        <div class="stat-value" id="connectionState">æœªè¿æ¥</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">ICE çŠ¶æ€</div>
        <div class="stat-value" id="iceState">æ–°å»º</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">è§†é¢‘è½¨é“</div>
        <div class="stat-value" id="videoTracks">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-title">éŸ³é¢‘è½¨é“</div>
        <div class="stat-value" id="audioTracks">0</div>
      </div>
    </div>

    <div class="logs" id="logs"></div>
  </div>

  <script>
    let ws = null;
    let pc = null;
    let serverIceServers = []; // å­˜å‚¨æœåŠ¡å™¨æä¾›çš„ICEæœåŠ¡å™¨é…ç½®
    const video = document.getElementById('remoteVideo');
    const statusSpan = document.getElementById('status');
    const statusIndicator = document.getElementById('statusIndicator');
    const logsDiv = document.getElementById('logs');
    const statsGrid = document.getElementById('statsGrid');

    let statsVisible = false;

    function log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const icon = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : type === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
      const logEntry = `[${timestamp}] ${icon} ${message}`;
      logsDiv.innerHTML += logEntry + '<br>';
      logsDiv.scrollTop = logsDiv.scrollHeight;
      console.log(logEntry);
    }

    function updateStatus(status, type = 'ready') {
      statusSpan.textContent = status;
      statusIndicator.className = `status-indicator status-${type}`;
      log(`çŠ¶æ€æ›´æ–°: ${status}`, type === 'error' ? 'error' : 'info');
    }

    function updateStats() {
      if (!pc) return;

      document.getElementById('connectionState').textContent = pc.connectionState;
      document.getElementById('iceState').textContent = pc.iceConnectionState;

      // Count tracks
      let videoTracks = 0;
      let audioTracks = 0;

      pc.getReceivers().forEach(receiver => {
        if (receiver.track) {
          if (receiver.track.kind === 'video') videoTracks++;
          if (receiver.track.kind === 'audio') audioTracks++;
        }
      });

      document.getElementById('videoTracks').textContent = videoTracks;
      document.getElementById('audioTracks').textContent = audioTracks;
    }

    function toggleStats() {
      statsVisible = !statsVisible;
      statsGrid.style.display = statsVisible ? 'grid' : 'none';
      if (statsVisible) {
        updateStats();
        // Update stats every second when visible
        if (!window.statsInterval) {
          window.statsInterval = setInterval(updateStats, 1000);
        }
      } else {
        if (window.statsInterval) {
          clearInterval(window.statsInterval);
          window.statsInterval = null;
        }
      }
    }

    function startCapture() {
      log('å¼€å§‹æ¡Œé¢æ•è·æµ‹è¯•...', 'info');
      updateStatus('æ­£åœ¨è¿æ¥...', 'connecting');

      // Connect to signaling server
      ws = new WebSocket(`ws://${window.location.host}/api/signaling`);

      ws.onopen = function () {
        log('âœ… WebSocket è¿æ¥æˆåŠŸ', 'success');
        updateStatus('å·²è¿æ¥åˆ°ä¿¡ä»¤æœåŠ¡å™¨', 'connected');
        log('â³ ç­‰å¾…æœåŠ¡å™¨é…ç½®...', 'info');
        // ä¸è¦ç«‹å³åˆ›å»ºPeerConnectionï¼Œç­‰å¾…welcomeæ¶ˆæ¯
      };

      ws.onmessage = function (event) {
        try {
          const message = JSON.parse(event.data);
          log(`æ”¶åˆ°æ¶ˆæ¯: ${message.type}`, 'info');

          switch (message.type) {
            case 'offer':
              handleOffer(message);
              break;
            case 'ice-candidate':
              handleIceCandidate(message);
              break;
            case 'welcome':
              log('âœ… æ”¶åˆ°æ¬¢è¿æ¶ˆæ¯', 'success');
              // æå–ICEæœåŠ¡å™¨é…ç½®
              if (message.data && message.data.session_config && message.data.session_config.ice_servers) {
                serverIceServers = message.data.session_config.ice_servers.map(server => ({
                  urls: server.urls,
                  username: server.username,
                  credential: server.credential
                }));
                log(`ğŸ“¡ æœåŠ¡å™¨æä¾›äº† ${serverIceServers.length} ä¸ª ICE æœåŠ¡å™¨`, 'success');
                serverIceServers.forEach((server, i) => {
                  log(`   ICE Server ${i + 1}: ${JSON.stringify(server.urls)}`, 'info');
                });
              } else {
                log('âš ï¸ æ¬¢è¿æ¶ˆæ¯ä¸­æ²¡æœ‰ICEæœåŠ¡å™¨é…ç½®ï¼Œå°†ä½¿ç”¨é»˜è®¤é…ç½®', 'warning');
              }
              
              // æ”¶åˆ°welcomeæ¶ˆæ¯åï¼Œåˆ›å»ºPeerConnectionå¹¶è¯·æ±‚offer
              log('ğŸ”§ ä½¿ç”¨æœåŠ¡å™¨é…ç½®åˆ›å»º PeerConnection...', 'info');
              createPeerConnection();
              
              // Request offer after a short delay
              setTimeout(() => {
                log('ğŸ“ è¯·æ±‚ WebRTC offer...', 'info');
                ws.send(JSON.stringify({
                  type: 'request-offer',
                  timestamp: Date.now(),
                  constraints: {
                    video: true,
                    audio: false
                  }
                }));
              }, 500);
              break;
            case 'pong':
              log('æ”¶åˆ° pong å“åº”', 'info');
              break;
            case 'error':
              log(`æœåŠ¡å™¨é”™è¯¯: ${message.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
              break;
            default:
              log(`æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${message.type}`, 'warning');
          }
        } catch (error) {
          log(`è§£ææ¶ˆæ¯å¤±è´¥: ${error}`, 'error');
        }
      };

      ws.onerror = function (error) {
        log(`WebSocket é”™è¯¯: ${error}`, 'error');
        updateStatus('WebSocket è¿æ¥é”™è¯¯', 'error');
      };

      ws.onclose = function (event) {
        log(`WebSocket è¿æ¥å…³é—­ (ä»£ç : ${event.code}, åŸå› : ${event.reason || 'æ— '})`, 'warning');
        updateStatus('è¿æ¥å·²æ–­å¼€', 'error');
      };
    }

    function createPeerConnection() {
      log('åˆ›å»º PeerConnection...', 'info');

      // ä½¿ç”¨æœåŠ¡å™¨æä¾›çš„ICEæœåŠ¡å™¨é…ç½®
      const config = {
        iceServers: serverIceServers,
        iceCandidatePoolSize: 10,
        iceTransportPolicy: 'all',  // ä½¿ç”¨æ‰€æœ‰å€™é€‰
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
      };

      log(`ä½¿ç”¨ ${config.iceServers.length} ä¸ª ICE æœåŠ¡å™¨:`, 'info');
      config.iceServers.forEach((server, i) => {
        log(`  ICE Server ${i + 1}: ${JSON.stringify(server.urls)}`, 'info');
      });

      pc = new RTCPeerConnection(config);

      pc.onicecandidate = function (event) {
        if (event.candidate) {
          log(`ç”Ÿæˆ ICE å€™é€‰: ${event.candidate.candidate.substring(0, 50)}...`, 'info');
          ws.send(JSON.stringify({
            type: 'ice-candidate',
            data: {
              candidate: {
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex
              }
            }
          }));
        } else {
          log('ICE å€™é€‰æ”¶é›†å®Œæˆ', 'success');
        }
      };

      pc.ontrack = function (event) {
        log('æ”¶åˆ°è¿œç¨‹è§†é¢‘è½¨é“!', 'success');
        updateStatus('è§†é¢‘æµå·²æ¥æ”¶', 'connected');
        video.srcObject = event.streams[0];

        // Show video stats
        const track = event.track;
        log(`è½¨é“ä¿¡æ¯: ç±»å‹=${track.kind}, ID=${track.id}, çŠ¶æ€=${track.readyState}`, 'info');

        // Update video element visibility
        video.style.display = 'block';
      };

      pc.onconnectionstatechange = function () {
        log(`è¿æ¥çŠ¶æ€: ${pc.connectionState}`, 'info');
        updateStatus(`è¿æ¥: ${pc.connectionState}`, pc.connectionState === 'connected' ? 'connected' : 'connecting');

        if (pc.connectionState === 'connected') {
          log('WebRTC è¿æ¥å»ºç«‹æˆåŠŸ!', 'success');
          updateStatus('æ¡Œé¢æ•è·å·²æ¿€æ´»', 'connected');
        } else if (pc.connectionState === 'failed') {
          log('WebRTC è¿æ¥å¤±è´¥', 'error');
          updateStatus('è¿æ¥å¤±è´¥', 'error');
        }

        updateStats();
      };

      pc.oniceconnectionstatechange = function () {
        log(`ICE è¿æ¥çŠ¶æ€: ${pc.iceConnectionState}`, 'info');
        updateStats();
      };

      pc.onicegatheringstatechange = function () {
        log(`ICE æ”¶é›†çŠ¶æ€: ${pc.iceGatheringState}`, 'info');
      };
    }

    async function handleOffer(message) {
      log('å¤„ç†æœåŠ¡å™¨ offer...', 'info');

      try {
        const offer = message.data.sdp || message.data;
        log(`Offer SDP é•¿åº¦: ${offer.sdp ? offer.sdp.length : 'N/A'} å­—ç¬¦`, 'info');

        // Check SDP content
        if (offer.sdp) {
          const hasVideo = offer.sdp.includes('m=video');
          const hasAudio = offer.sdp.includes('m=audio');
          log(`SDP å†…å®¹: è§†é¢‘=${hasVideo}, éŸ³é¢‘=${hasAudio}`, hasVideo ? 'success' : 'warning');

          if (!hasVideo) {
            log('è­¦å‘Š: SDP ä¸­æ²¡æœ‰è§†é¢‘è½¨é“ï¼Œè¿™å¯èƒ½æ˜¯é»‘å±çš„åŸå› !', 'warning');
          }
        }

        await pc.setRemoteDescription({
          type: 'offer',
          sdp: offer.sdp
        });

        log('è¿œç¨‹æè¿°è®¾ç½®æˆåŠŸï¼Œåˆ›å»º answer...', 'success');
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        log('å‘é€ answer åˆ°æœåŠ¡å™¨...', 'info');
        ws.send(JSON.stringify({
          type: 'answer',
          data: {
            sdp: {
              type: 'answer',
              sdp: answer.sdp
            }
          }
        }));

        updateStatus('Answer å·²å‘é€ï¼Œç­‰å¾…è¿æ¥...', 'connecting');
      } catch (error) {
        log(`å¤„ç† offer å¤±è´¥: ${error}`, 'error');
        updateStatus('å¤„ç† offer é”™è¯¯', 'error');
      }
    }

    async function handleIceCandidate(message) {
      log(`ğŸ“¥ æ”¶åˆ°æœåŠ¡å™¨ ICE å€™é€‰æ¶ˆæ¯`, 'info');
      
      const candidateData = message.data;
      
      // è¯¦ç»†æ—¥å¿—
      log(`   å®Œæ•´æ¶ˆæ¯: ${JSON.stringify(message, null, 2)}`, 'info');
      log(`   candidateDataç±»å‹: ${typeof candidateData}`, 'info');
      log(`   candidateData.candidateç±»å‹: ${typeof candidateData?.candidate}`, 'info');
      
      // æ£€æŸ¥æ•°æ®æ ¼å¼
      if (!candidateData || !candidateData.candidate) {
        log(`âŒ ICE å€™é€‰æ•°æ®æ ¼å¼é”™è¯¯: ${JSON.stringify(candidateData)}`, 'error');
        return;
      }
      
      log(`   å€™é€‰å­—ç¬¦ä¸²: ${candidateData.candidate.substring(0, 80)}...`, 'info');
      log(`   sdpMid: ${candidateData.sdpMid}`, 'info');
      log(`   sdpMLineIndex: ${candidateData.sdpMLineIndex}`, 'info');

      try {
        await pc.addIceCandidate({
          candidate: candidateData.candidate,
          sdpMid: candidateData.sdpMid,
          sdpMLineIndex: candidateData.sdpMLineIndex
        });
        log('âœ… ICE å€™é€‰æ·»åŠ æˆåŠŸ', 'success');
      } catch (error) {
        log(`âŒ æ·»åŠ  ICE å€™é€‰å¤±è´¥: ${error.message}`, 'error');
        log(`   é”™è¯¯è¯¦æƒ…: ${JSON.stringify(error)}`, 'error');
      }
    }

    function stopCapture() {
      log('åœæ­¢æ¡Œé¢æ•è·...', 'info');

      if (pc) {
        pc.close();
        pc = null;
        log('PeerConnection å·²å…³é—­', 'info');
      }

      if (ws) {
        ws.close();
        ws = null;
        log('WebSocket å·²å…³é—­', 'info');
      }

      video.srcObject = null;
      video.style.display = 'none';
      updateStatus('å·²åœæ­¢', 'ready');

      // Clear stats interval
      if (window.statsInterval) {
        clearInterval(window.statsInterval);
        window.statsInterval = null;
      }
    }

    function clearLogs() {
      logsDiv.innerHTML = '';
    }

    // Initialize
    log('é¡µé¢åŠ è½½å®Œæˆï¼Œå‡†å¤‡å¼€å§‹æ¡Œé¢æ•è·æµ‹è¯•', 'success');
    log('ç‚¹å‡» "å¼€å§‹æ¡Œé¢æ•è·" æŒ‰é’®å¼€å§‹æµ‹è¯•', 'info');

    // Auto-update stats if visible
    setInterval(() => {
      if (statsVisible && pc) {
        updateStats();
      }
    }, 1000);
  </script>
</body>

</html>